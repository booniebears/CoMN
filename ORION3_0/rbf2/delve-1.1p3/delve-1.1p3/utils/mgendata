#!/bin/sh
# \
	exec delvesh "$0" ${1+"$@"}

# ----------------------------------------------------------------------
# $Id: mgendata,v 1.9.2.6.2.1 1997/06/11 18:29:23 revow Exp $
#
# This script generates delve data files.  It must be run within a
# Delve working directory (generated by "mgendir").  For a full
# description of what this means, see the "delve" documentation.
#
# Besides command line flags, it uses the following environment
# variables:
#
# DELVE_LIBRARY	- the library where the Tcl library files are.
# DELVE_PATH - the colon separated list of directories to use as the
# 		overlapping delve directory hierarchy.
#
# Author: Delve (delve@cs.toronto.edu)
#
# Copyright (c) 1995-1996 The University of Toronto.
#
# See the file "copyright" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# ----------------------------------------------------------------------

# ----------------------------------------------------------------------
# The string "usage" has a nicely formatted message describing the
# usage of the script. It is used in error and help messages.
# ----------------------------------------------------------------------

set usage "usage: [file tail $argv0] \[ options \] \[ path \]
    Where 'options' are:
	-c file	Set the file containing the task coding attributes.
	-d Turn on error stack traces for debugging.
	-h Print this help message.
	-q Run quietly.

    And 'path' is:
	The true path of a method's dataset, prototask, or task
	directory in which to generate the files.  If 'path' is not
	specified, it defaults to the current working directory."

# ----------------------------------------------------------------------
# The procedure "parseOptions" parses all the command line options in
# "list" and leaves the result in the array "options". If an error
# occurs, it uses "usage" in the error message. The procedure returns
# all arguments left in "list" after removing options. Default options
# are set here as well.
# ----------------------------------------------------------------------

proc parseOptions { list usage optionsName } {
    upvar $optionsName options ;
#   global d_priv;

    while { ![lempty $list] } {
	set option [lpop list] ;
	switch -glob -- $option {
	    -c		{ set options(coding)	[lpop list] }
	    -d		{ delve_debug 1 }
	    -h		{ puts stderr "$usage" ; exit 0 }
	    -q		{delve_quiet 1}
	    --		{ break }
	    -*		{ error "Illegal option \"$option\"\n$usage" }
	    default	{ lpush list $option ; break }
	}
    }
    return $list ;
}

#----------------------------------------------------------------------#
# The "mgendata" procedure generates the data for all tasks in "where"
# using data from "dataDir".
#----------------------------------------------------------------------#

proc mgendata { path force } {
    global options ;
    global d_priv ;
    
    if ![file exists $path] {
	error "directory \"$path\" not found" ;
    }

    set cpath	[d_cpath $path] ;
    if ![d_exists $cpath] {
	error "\"$cpath\" does not exist"
    }
    set type	[d_type $cpath] ;

    if { [string compare $type "dataset"] == 0 } {
	foreach subdir [d_info $cpath prototasks] {
	    if [file exists $path/$subdir] {
		mgendata $path/$subdir $force ;
	    }
	}

    } elseif { [string compare $type "prototask"] == 0 } {
	foreach subdir [d_info $cpath tasks] {
	    if [file exists $path/$subdir] {
		mgendata $path/$subdir $force ;
	    }
	}

    } elseif { [string compare $type "task"] == 0 } {
	if { [string compare $path "."] != 0 } {
	    puts stderr $path ;
	}
	
	#
	# Find the prototask data file. If there are multiple copies,
	# generate an error. If there is no copy, make one in the
	# parallel data directory to the working path.
	#

	set datafiles [d_paths [file dirname $cpath]/$d_priv(prototaskFile)]

	if { [llength $datafiles] > 1 } {
	    error "multiple copies of prototask data file found: $datafiles"

	} elseif { [llength $datafiles] == 0 } {
	    set gendir [delve_root $path]/data[file dirname $cpath] ;
	    if ![file exists $gendir] {
		mkdir -path $gendir ;
	    }
	    genPrototask [file dirname $cpath] $gendir/$d_priv(prototaskFile) 1
	}	    


        # Clear the attribute list from previous if doing
        # multiple tasks
        acdc_clear

	#
	# Load the encoding file if one was specified.
	#

	if [info exists options(coding)] {
	    loadEncoding $options(coding) \
		[concat [d_info $cpath inputs] [d_info $cpath targets]] ;
	}

        #
        # Check if any filters were specified in the prototask
	# - Removed this capability
#       checkForFilterProc filterBeforeCoding filter-before-coding $cpath
#       checkForFilterProc filterAfterCoding filter-after-coding $cpath

      

	# Finally, generate the task data.
	#

	genTask $cpath $path 1 ;
    }
}

# Check for Prototask specified filters
# Currently not used
proc checkForFilterProc { arrayName keyName cpath } {

   global d_priv

   catch { set d_priv($arrayName) [d_info [file dirname $cpath] $keyName]
   }

   if { [info exists  d_priv($arrayName) ] } {
      if { [file executable $d_priv($arrayName)] != 1 } { 
	 error "mgendata: Prototask $keyName ($d_priv($arrayName)) not available" ;
      }
   }
}


#----------------------------------------------------------------------#
# Parse the command line.
#----------------------------------------------------------------------#

set argv [parseOptions $argv $usage options] ;

# ----------------------------------------------------------------------
# And here we go...
# ----------------------------------------------------------------------

if { [llength $argv] == 0 } {
    set path "." ;
} elseif { [llength $argv] == 1 } {
    set path [cleanpath [lindex $argv 0]] ;
} else {
    error $usage ;
}

mgendata $path 1 ;

exit 0
